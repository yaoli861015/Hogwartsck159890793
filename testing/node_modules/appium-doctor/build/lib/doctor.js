"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FixSkippedError = exports.DoctorCheck = exports.Doctor = void 0;

require("source-map-support/register");

require("colors");

var _lodash = _interopRequireDefault(require("lodash"));

var _logger = _interopRequireDefault(require("./logger"));

var _package = require("../../package.json");

class FixSkippedError extends Error {}

exports.FixSkippedError = FixSkippedError;

class DoctorCheck {
  constructor(opts = {}) {
    this.autofix = !!opts.autofix;
  }

  diagnose() {
    throw new Error('Not Implemented!');
  }

  fix() {
    throw new Error('Not Implemented!');
  }

}

exports.DoctorCheck = DoctorCheck;

class Doctor {
  constructor() {
    this.checks = [];
    this.checkOptionals = [];
    this.toFix = [];
    this.toFixOptionals = [];
  }

  register(checks) {
    checks = Array.isArray(checks) ? checks : [checks];
    this.checks = this.checks.concat(checks);
  }

  async diagnose() {
    _logger.default.info(`### Diagnostic for ${'necessary'.green} dependencies starting ###`);

    this.toFix = [];

    for (const check of this.checks) {
      const res = await check.diagnose();

      if (res.optional) {
        this.checkOptionals.push(check);
        continue;
      }

      await this.diagnosticResultMessage(res, this.toFix, check);
    }

    _logger.default.info(`### Diagnostic for necessary dependencies completed, ${await this.fixMessage(this.toFix.length)}. ###`);

    _logger.default.info('');

    _logger.default.info(`### Diagnostic for ${'optional'.yellow} dependencies starting ###`);

    this.toFixOptionals = [];

    for (const checkOptional of this.checkOptionals) {
      await this.diagnosticResultMessage(await checkOptional.diagnose(), this.toFixOptionals, checkOptional);
    }

    _logger.default.info(`### Diagnostic for optional dependencies completed, ${await this.fixMessage(this.toFixOptionals.length, true)}. ###`);

    _logger.default.info('');
  }

  async reportManualFixes(fix, fixOptioal) {
    const manualFixes = _lodash.default.filter(fix, f => {
      var _f$check;

      return !(f === null || f === void 0 ? void 0 : (_f$check = f.check) === null || _f$check === void 0 ? void 0 : _f$check.autofix);
    });

    const manualFixesOptional = _lodash.default.filter(fixOptioal, f => {
      var _f$check2;

      return !(f === null || f === void 0 ? void 0 : (_f$check2 = f.check) === null || _f$check2 === void 0 ? void 0 : _f$check2.autofix);
    });

    if (manualFixes.length > 0) {
      _logger.default.info('### Manual Fixes Needed ###');

      _logger.default.info('The configuration cannot be automatically fixed, please do the following first:');

      const fixMessages = [];

      for (const f of manualFixes) {
        fixMessages.push(await f.check.fix());
      }

      for (const m of _lodash.default.uniq(fixMessages)) {
        _logger.default.warn(` \u279C ${m}`);
      }

      _logger.default.info('');
    }

    if (manualFixesOptional.length > 0) {
      _logger.default.info('### Optional Manual Fixes ###');

      _logger.default.info('The configuration can install optionally. Please do the following manually:');

      const fixMessages = [];

      for (const f of manualFixesOptional) {
        fixMessages.push(await f.check.fix());
      }

      for (const m of _lodash.default.uniq(fixMessages)) {
        _logger.default.warn(` \u279C ${m}`);
      }

      _logger.default.info('');
    }

    if (manualFixes.length > 0 || manualFixesOptional.length > 0) {
      _logger.default.info('###');

      _logger.default.info('');

      _logger.default.info('Bye! Run appium-doctor again when all manual fixes have been applied!');

      _logger.default.info('');

      return true;
    }

    return false;
  }

  async runAutoFix(f) {
    _logger.default.info(`### Fixing: ${f.error} ###`);

    try {
      await f.check.fix();
    } catch (err) {
      if (err instanceof FixSkippedError) {
        _logger.default.info(`### Skipped fix ###`);

        return;
      } else {
        _logger.default.warn(`${err}`.replace(/\n$/g, ''));

        _logger.default.info(`### Fix did not succeed ###`);

        return;
      }
    }

    _logger.default.info('Checking if this was fixed:');

    let res = await f.check.diagnose();

    if (res.ok) {
      f.fixed = true;

      _logger.default.info(` ${'\u2714'.green} ${res.message}`);

      _logger.default.info(`### Fix was successfully applied ###`);
    } else {
      _logger.default.info(` ${'\u2716'.red} ${res.message}`);

      _logger.default.info(`### Fix was applied but issue remains ###`);
    }
  }

  async runAutoFixes() {
    let autoFixes = _lodash.default.filter(this.toFix, f => {
      var _f$check3;

      return f === null || f === void 0 ? void 0 : (_f$check3 = f.check) === null || _f$check3 === void 0 ? void 0 : _f$check3.autofix;
    });

    for (let f of autoFixes) {
      await this.runAutoFix(f);

      _logger.default.info('');
    }

    if (_lodash.default.find(autoFixes, f => !f.fixed)) {
      _logger.default.info('Bye! A few issues remain, fix manually and/or rerun appium-doctor!');
    } else {
      _logger.default.info('Bye! All issues have been fixed!');
    }

    _logger.default.info('');
  }

  async run() {
    _logger.default.info(`Appium Doctor v.${_package.version}`);

    await this.diagnose();

    if (await this.reportSuccess(this.toFix.length, this.toFixOptionals.length)) {
      return;
    }

    if (await this.reportManualFixes(this.toFix, this.toFixOptionals)) {
      return;
    }

    await this.runAutoFixes();
  }

  async diagnosticResultMessage(result, toFixList, check) {
    if (result.ok) {
      _logger.default.info(` ${'\u2714'.green} ${result.message}`);
    } else {
      const errorMessage = result.optional ? ` ${'\u2716'.yellow} ${result.message}` : ` ${'\u2716'.red} ${result.message}`;

      _logger.default.warn(errorMessage);

      toFixList.push({
        error: errorMessage,
        check
      });
    }
  }

  async fixMessage(length, optional = false) {
    let message;

    switch (length) {
      case 0:
        message = 'no fix';
        break;

      case 1:
        message = 'one fix';
        break;

      default:
        message = `${length} fixes`;
    }

    return `${message} ${optional ? 'possible' : 'needed'}`;
  }

  async reportSuccess(length, lengthOptional) {
    if (length === 0 && lengthOptional === 0) {
      _logger.default.info('Everything looks good, bye!');

      _logger.default.info('');

      return true;
    } else {
      return false;
    }
  }

}

exports.Doctor = Doctor;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9kb2N0b3IuanMiXSwibmFtZXMiOlsiRml4U2tpcHBlZEVycm9yIiwiRXJyb3IiLCJEb2N0b3JDaGVjayIsImNvbnN0cnVjdG9yIiwib3B0cyIsImF1dG9maXgiLCJkaWFnbm9zZSIsImZpeCIsIkRvY3RvciIsImNoZWNrcyIsImNoZWNrT3B0aW9uYWxzIiwidG9GaXgiLCJ0b0ZpeE9wdGlvbmFscyIsInJlZ2lzdGVyIiwiQXJyYXkiLCJpc0FycmF5IiwiY29uY2F0IiwibG9nIiwiaW5mbyIsImdyZWVuIiwiY2hlY2siLCJyZXMiLCJvcHRpb25hbCIsInB1c2giLCJkaWFnbm9zdGljUmVzdWx0TWVzc2FnZSIsImZpeE1lc3NhZ2UiLCJsZW5ndGgiLCJ5ZWxsb3ciLCJjaGVja09wdGlvbmFsIiwicmVwb3J0TWFudWFsRml4ZXMiLCJmaXhPcHRpb2FsIiwibWFudWFsRml4ZXMiLCJfIiwiZmlsdGVyIiwiZiIsIm1hbnVhbEZpeGVzT3B0aW9uYWwiLCJmaXhNZXNzYWdlcyIsIm0iLCJ1bmlxIiwid2FybiIsInJ1bkF1dG9GaXgiLCJlcnJvciIsImVyciIsInJlcGxhY2UiLCJvayIsImZpeGVkIiwibWVzc2FnZSIsInJlZCIsInJ1bkF1dG9GaXhlcyIsImF1dG9GaXhlcyIsImZpbmQiLCJydW4iLCJ2ZXJzaW9uIiwicmVwb3J0U3VjY2VzcyIsInJlc3VsdCIsInRvRml4TGlzdCIsImVycm9yTWVzc2FnZSIsImxlbmd0aE9wdGlvbmFsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLE1BQU1BLGVBQU4sU0FBOEJDLEtBQTlCLENBQW9DOzs7O0FBR3BDLE1BQU1DLFdBQU4sQ0FBa0I7QUFDaEJDLEVBQUFBLFdBQVcsQ0FBRUMsSUFBSSxHQUFHLEVBQVQsRUFBYTtBQUN0QixTQUFLQyxPQUFMLEdBQWUsQ0FBQyxDQUFDRCxJQUFJLENBQUNDLE9BQXRCO0FBQ0Q7O0FBRURDLEVBQUFBLFFBQVEsR0FBSTtBQUFF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QUZELE1BRU87QUFDTCxZQUFNVSxZQUFZLEdBQUdGLE1BQU0sQ0FBQ2hDLFFBQVAsR0FBbUIsSUFBRyxTQUFTSyxNQUFPLElBQUcyQixNQUFNLENBQUNSLE9BQVEsRUFBeEQsR0FBNkQsSUFBRyxTQUFTQyxHQUFJLElBQUdPLE1BQU0sQ0FBQ1IsT0FBUSxFQUFwSDs7QUFDQTdCLHNCQUFJc0IsSUFBSixDQUFTaUIsWUFBVDs7QUFDQUQsTUFBQUEsU0FBUyxDQUFDaEMsSUFBVixDQUFlO0FBQ2JrQixRQUFBQSxLQUFLLEVBQUVlLFlBRE07QUFFYnBDLFFBQUFBO0FBRmEsT0FBZjtBQUlEO0FBQ0Y7O0FBRUQsUUFBTUssVUFBTixDQUFrQkMsTUFBbEIsRUFBMEJKLFFBQVEsR0FBRyxLQUFyQyxFQUE0QztBQUMxQyxRQUFJd0IsT0FBSjs7QUFDQSxZQUFRcEIsTUFBUjtBQUNFLFdBQUssQ0FBTDtBQUNFb0IsUUFBQUEsT0FBTyxHQUFHLFFBQVY7QUFDQTs7QUFDRixXQUFLLENBQUw7QUFDRUEsUUFBQUEsT0FBTyxHQUFHLFNBQVY7QUFDQTs7QUFDRjtBQUNFQSxRQUFBQSxPQUFPLEdBQUksR0FBRXBCLE1BQU8sUUFBcEI7QUFSSjs7QUFVQSxXQUFRLEdBQUVvQixPQUFRLElBQUd4QixRQUFRLEdBQUcsVUFBSCxHQUFnQixRQUFTLEVBQXREO0FBQ0Q7O0FBRUQsUUFBTStCLGFBQU4sQ0FBcUIzQixNQUFyQixFQUE2QitCLGNBQTdCLEVBQTZDO0FBQzNDLFFBQUkvQixNQUFNLEtBQUssQ0FBWCxJQUFnQitCLGNBQWMsS0FBSyxDQUF2QyxFQUEwQztBQUN4Q3hDLHNCQUFJQyxJQUFKLENBQVMsNkJBQVQ7O0FBQ0FELHNCQUFJQyxJQUFKLENBQVMsRUFBVDs7QUFDQSxhQUFPLElBQVA7QUFDRCxLQUpELE1BSU87QUFDTCxhQUFPLEtBQVA7QUFDRDtBQUNGOztBQXhLVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnY29sb3JzJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5cblxuY2xhc3MgRml4U2tpcHBlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuXG5jbGFzcyBEb2N0b3JDaGVjayB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICB0aGlzLmF1dG9maXggPSAhIW9wdHMuYXV0b2ZpeDtcbiAgfVxuXG4gIGRpYWdub3NlICgpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQhJyk7IH1cblxuICBmaXggKCkge1xuICAgIC8vIHJldHVybiBzdHJpbmcgZm9yIG1hbnVhbCBmaXhlcy5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCEnKTtcbiAgfVxufVxuXG5jbGFzcyBEb2N0b3Ige1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5jaGVja3MgPSBbXTtcbiAgICB0aGlzLmNoZWNrT3B0aW9uYWxzID0gW107XG4gICAgdGhpcy50b0ZpeCA9IFtdO1xuICAgIHRoaXMudG9GaXhPcHRpb25hbHMgPSBbXTtcbiAgfVxuXG4gIHJlZ2lzdGVyIChjaGVja3MpIHtcbiAgICBjaGVja3MgPSBBcnJheS5pc0FycmF5KGNoZWNrcykgPyBjaGVja3MgOiBbY2hlY2tzXTtcbiAgICB0aGlzLmNoZWNrcyA9IHRoaXMuY2hlY2tzLmNvbmNhdChjaGVja3MpO1xuICB9XG5cbiAgYXN5bmMgZGlhZ25vc2UgKCkge1xuICAgIGxvZy5pbmZvKGAjIyMgRGlhZ25vc3RpYyBmb3IgJHsnbmVjZXNzYXJ5Jy5ncmVlbn0gZGVwZW5kZW5jaWVzIHN0YXJ0aW5nICMjI2ApO1xuICAgIHRoaXMudG9GaXggPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuY2hlY2tzKSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBjaGVjay5kaWFnbm9zZSgpO1xuICAgICAgaWYgKHJlcy5vcHRpb25hbCkge1xuICAgICAgICB0aGlzLmNoZWNrT3B0aW9uYWxzLnB1c2goY2hlY2spO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuZGlhZ25vc3RpY1Jlc3VsdE1lc3NhZ2UocmVzLCB0aGlzLnRvRml4LCBjaGVjayk7XG4gICAgfVxuICAgIGxvZy5pbmZvKGAjIyMgRGlhZ25vc3RpYyBmb3IgbmVjZXNzYXJ5IGRlcGVuZGVuY2llcyBjb21wbGV0ZWQsICR7YXdhaXQgdGhpcy5maXhNZXNzYWdlKHRoaXMudG9GaXgubGVuZ3RoKX0uICMjI2ApO1xuICAgIGxvZy5pbmZvKCcnKTtcblxuICAgIGxvZy5pbmZvKGAjIyMgRGlhZ25vc3RpYyBmb3IgJHsnb3B0aW9uYWwnLnllbGxvd30gZGVwZW5kZW5jaWVzIHN0YXJ0aW5nICMjI2ApO1xuICAgIHRoaXMudG9GaXhPcHRpb25hbHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoZWNrT3B0aW9uYWwgb2YgdGhpcy5jaGVja09wdGlvbmFscykge1xuICAgICAgYXdhaXQgdGhpcy5kaWFnbm9zdGljUmVzdWx0TWVzc2FnZShhd2FpdCBjaGVja09wdGlvbmFsLmRpYWdub3NlKCksIHRoaXMudG9GaXhPcHRpb25hbHMsIGNoZWNrT3B0aW9uYWwpO1xuICAgIH1cbiAgICBsb2cuaW5mbyhgIyMjIERpYWdub3N0aWMgZm9yIG9wdGlvbmFsIGRlcGVuZGVuY2llcyBjb21wbGV0ZWQsICR7YXdhaXQgdGhpcy5maXhNZXNzYWdlKHRoaXMudG9GaXhPcHRpb25hbHMubGVuZ3RoLCB0cnVlKX0uICMjI2ApO1xuICAgIGxvZy5pbmZvKCcnKTtcbiAgfVxuXG4gIGFzeW5jIHJlcG9ydE1hbnVhbEZpeGVzIChmaXgsIGZpeE9wdGlvYWwpIHtcbiAgICBjb25zdCBtYW51YWxGaXhlcyA9IF8uZmlsdGVyKGZpeCwgKGYpID0+ICFmPy5jaGVjaz8uYXV0b2ZpeCk7XG4gICAgY29uc3QgbWFudWFsRml4ZXNPcHRpb25hbCA9IF8uZmlsdGVyKGZpeE9wdGlvYWwsIChmKSA9PiAhZj8uY2hlY2s/LmF1dG9maXgpO1xuXG4gICAgaWYgKG1hbnVhbEZpeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvZy5pbmZvKCcjIyMgTWFudWFsIEZpeGVzIE5lZWRlZCAjIyMnKTtcbiAgICAgIGxvZy5pbmZvKCdUaGUgY29uZmlndXJhdGlvbiBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBmaXhlZCwgcGxlYXNlIGRvIHRoZSBmb2xsb3dpbmcgZmlyc3Q6Jyk7XG4gICAgICAvLyBmb3IgbWFudWFsIGZpeGVzLCB0aGUgZml4IG1ldGhvZCBhbHdheXMgcmV0dXJuIGEgc3RyaW5nXG4gICAgICBjb25zdCBmaXhNZXNzYWdlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmIG9mIG1hbnVhbEZpeGVzKSB7XG4gICAgICAgIGZpeE1lc3NhZ2VzLnB1c2goYXdhaXQgZi5jaGVjay5maXgoKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgXy51bmlxKGZpeE1lc3NhZ2VzKSkge1xuICAgICAgICBsb2cud2FybihgIFxcdTI3OUMgJHttfWApO1xuICAgICAgfVxuICAgICAgbG9nLmluZm8oJycpO1xuICAgIH1cbiAgICBpZiAobWFudWFsRml4ZXNPcHRpb25hbC5sZW5ndGggPiAwKSB7XG4gICAgICBsb2cuaW5mbygnIyMjIE9wdGlvbmFsIE1hbnVhbCBGaXhlcyAjIyMnKTtcbiAgICAgIGxvZy5pbmZvKCdUaGUgY29uZmlndXJhdGlvbiBjYW4gaW5zdGFsbCBvcHRpb25hbGx5LiBQbGVhc2UgZG8gdGhlIGZvbGxvd2luZyBtYW51YWxseTonKTtcbiAgICAgIC8vIGZvciBtYW51YWwgZml4ZXMsIHRoZSBmaXggbWV0aG9kIGFsd2F5cyByZXR1cm4gYSBzdHJpbmdcbiAgICAgIGNvbnN0IGZpeE1lc3NhZ2VzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGYgb2YgbWFudWFsRml4ZXNPcHRpb25hbCkge1xuICAgICAgICBmaXhNZXNzYWdlcy5wdXNoKGF3YWl0IGYuY2hlY2suZml4KCkpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBtIG9mIF8udW5pcShmaXhNZXNzYWdlcykpIHtcbiAgICAgICAgbG9nLndhcm4oYCBcXHUyNzlDICR7bX1gKTtcbiAgICAgIH1cbiAgICAgIGxvZy5pbmZvKCcnKTtcbiAgICB9XG5cbiAgICBpZiAobWFudWFsRml4ZXMubGVuZ3RoID4gMCB8fCBtYW51YWxGaXhlc09wdGlvbmFsLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvZy5pbmZvKCcjIyMnKTtcbiAgICAgIGxvZy5pbmZvKCcnKTtcbiAgICAgIGxvZy5pbmZvKCdCeWUhIFJ1biBhcHBpdW0tZG9jdG9yIGFnYWluIHdoZW4gYWxsIG1hbnVhbCBmaXhlcyBoYXZlIGJlZW4gYXBwbGllZCEnKTtcbiAgICAgIGxvZy5pbmZvKCcnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBhc3luYyBydW5BdXRvRml4IChmKSB7XG4gICAgbG9nLmluZm8oYCMjIyBGaXhpbmc6ICR7Zi5lcnJvcn0gIyMjYCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGYuY2hlY2suZml4KCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRml4U2tpcHBlZEVycm9yKSB7XG4gICAgICAgIGxvZy5pbmZvKGAjIyMgU2tpcHBlZCBmaXggIyMjYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZy53YXJuKGAke2Vycn1gLnJlcGxhY2UoL1xcbiQvZywgJycpKTtcbiAgICAgICAgbG9nLmluZm8oYCMjIyBGaXggZGlkIG5vdCBzdWNjZWVkICMjI2ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5pbmZvKCdDaGVja2luZyBpZiB0aGlzIHdhcyBmaXhlZDonKTtcbiAgICBsZXQgcmVzID0gYXdhaXQgZi5jaGVjay5kaWFnbm9zZSgpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGYuZml4ZWQgPSB0cnVlO1xuICAgICAgbG9nLmluZm8oYCAkeydcXHUyNzE0Jy5ncmVlbn0gJHtyZXMubWVzc2FnZX1gKTtcbiAgICAgIGxvZy5pbmZvKGAjIyMgRml4IHdhcyBzdWNjZXNzZnVsbHkgYXBwbGllZCAjIyNgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmluZm8oYCAkeydcXHUyNzE2Jy5yZWR9ICR7cmVzLm1lc3NhZ2V9YCk7XG4gICAgICBsb2cuaW5mbyhgIyMjIEZpeCB3YXMgYXBwbGllZCBidXQgaXNzdWUgcmVtYWlucyAjIyNgKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBydW5BdXRvRml4ZXMgKCkge1xuICAgIGxldCBhdXRvRml4ZXMgPSBfLmZpbHRlcih0aGlzLnRvRml4LCAoZikgPT4gZj8uY2hlY2s/LmF1dG9maXgpO1xuICAgIGZvciAobGV0IGYgb2YgYXV0b0ZpeGVzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkF1dG9GaXgoZik7XG4gICAgICBsb2cuaW5mbygnJyk7XG4gICAgfVxuICAgIGlmIChfLmZpbmQoYXV0b0ZpeGVzLCAoZikgPT4gIWYuZml4ZWQpKSB7XG4gICAgICAvLyBhIGZldyBpc3N1ZXMgcmVtYWluLlxuICAgICAgbG9nLmluZm8oJ0J5ZSEgQSBmZXcgaXNzdWVzIHJlbWFpbiwgZml4IG1hbnVhbGx5IGFuZC9vciByZXJ1biBhcHBpdW0tZG9jdG9yIScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3RoaW5nIGxlZnQgdG8gZml4LlxuICAgICAgbG9nLmluZm8oJ0J5ZSEgQWxsIGlzc3VlcyBoYXZlIGJlZW4gZml4ZWQhJyk7XG4gICAgfVxuICAgIGxvZy5pbmZvKCcnKTtcbiAgfVxuXG4gIGFzeW5jIHJ1biAoKSB7XG4gICAgbG9nLmluZm8oYEFwcGl1bSBEb2N0b3Igdi4ke3ZlcnNpb259YCk7XG4gICAgYXdhaXQgdGhpcy5kaWFnbm9zZSgpO1xuICAgIGlmIChhd2FpdCB0aGlzLnJlcG9ydFN1Y2Nlc3ModGhpcy50b0ZpeC5sZW5ndGgsIHRoaXMudG9GaXhPcHRpb25hbHMubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXdhaXQgdGhpcy5yZXBvcnRNYW51YWxGaXhlcyh0aGlzLnRvRml4LCB0aGlzLnRvRml4T3B0aW9uYWxzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnJ1bkF1dG9GaXhlcygpO1xuICB9XG5cbiAgLy8vLyBnZW5lcmF0aW5nIG1lc3NhZ2VzXG4gIGFzeW5jIGRpYWdub3N0aWNSZXN1bHRNZXNzYWdlIChyZXN1bHQsIHRvRml4TGlzdCwgY2hlY2spIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWF3YWl0XG4gICAgaWYgKHJlc3VsdC5vaykge1xuICAgICAgbG9nLmluZm8oYCAkeydcXHUyNzE0Jy5ncmVlbn0gJHtyZXN1bHQubWVzc2FnZX1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gcmVzdWx0Lm9wdGlvbmFsID8gYCAkeydcXHUyNzE2Jy55ZWxsb3d9ICR7cmVzdWx0Lm1lc3NhZ2V9YCA6IGAgJHsnXFx1MjcxNicucmVkfSAke3Jlc3VsdC5tZXNzYWdlfWA7XG4gICAgICBsb2cud2FybihlcnJvck1lc3NhZ2UpO1xuICAgICAgdG9GaXhMaXN0LnB1c2goe1xuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgICBjaGVja1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZml4TWVzc2FnZSAobGVuZ3RoLCBvcHRpb25hbCA9IGZhbHNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1hd2FpdFxuICAgIGxldCBtZXNzYWdlO1xuICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIG1lc3NhZ2UgPSAnbm8gZml4JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIG1lc3NhZ2UgPSAnb25lIGZpeCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbWVzc2FnZSA9IGAke2xlbmd0aH0gZml4ZXNgO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bWVzc2FnZX0gJHtvcHRpb25hbCA/ICdwb3NzaWJsZScgOiAnbmVlZGVkJ31gO1xuICB9XG5cbiAgYXN5bmMgcmVwb3J0U3VjY2VzcyAobGVuZ3RoLCBsZW5ndGhPcHRpb25hbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtYXdhaXRcbiAgICBpZiAobGVuZ3RoID09PSAwICYmIGxlbmd0aE9wdGlvbmFsID09PSAwKSB7XG4gICAgICBsb2cuaW5mbygnRXZlcnl0aGluZyBsb29rcyBnb29kLCBieWUhJyk7XG4gICAgICBsb2cuaW5mbygnJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBEb2N0b3IsIERvY3RvckNoZWNrLCBGaXhTa2lwcGVkRXJyb3IgfTtcbiJdLCJmaWxlIjoibGliL2RvY3Rvci5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
